#!/bin/bash
# Pre-commit hook to prevent committing secrets and sensitive data
# This hook scans for common patterns of API keys, passwords, and secrets

set -e

# Colors for output
RED='\033[0;31m'
YELLOW='\033[1;33m'
GREEN='\033[0;32m'
NC='\033[0m' # No Color

echo -e "${GREEN}Running security pre-commit checks...${NC}"

# Function to check for secrets
check_secrets() {
    local files=$(git diff --cached --name-only --diff-filter=ACM)
    local found_secrets=0
    
    # Skip if no files to check
    if [ -z "$files" ]; then
        return 0
    fi
    
    # Patterns to search for
    local patterns=(
        # API Keys
        "api[_-]?key['\"]?\s*[:=]\s*['\"][a-zA-Z0-9_-]{20,}['\"]"
        "apikey['\"]?\s*[:=]\s*['\"][a-zA-Z0-9_-]{20,}['\"]"
        
        # Anthropic API keys
        "sk-ant-[a-zA-Z0-9_-]{95,}"
        
        # OpenAI API keys
        "sk-[a-zA-Z0-9]{48}"
        
        # Generic secrets
        "secret['\"]?\s*[:=]\s*['\"][^'\"]{8,}['\"]"
        "password['\"]?\s*[:=]\s*['\"][^'\"]{8,}['\"]"
        "token['\"]?\s*[:=]\s*['\"][a-zA-Z0-9_-]{20,}['\"]"
        
        # AWS keys
        "AKIA[0-9A-Z]{16}"
        
        # Private keys
        "-----BEGIN (RSA |DSA |EC )?PRIVATE KEY-----"
        
        # Generic environment variables with secrets
        "export\s+[A-Z_]+KEY\s*=\s*['\"]?[a-zA-Z0-9_-]{20,}"
        "export\s+[A-Z_]+SECRET\s*=\s*['\"]?[a-zA-Z0-9_-]{20,}"
        "export\s+[A-Z_]+TOKEN\s*=\s*['\"]?[a-zA-Z0-9_-]{20,}"
    )
    
    for file in $files; do
        # Skip binary files (use file command if available, otherwise skip check)
        if command -v file >/dev/null 2>&1; then
            if file "$file" 2>/dev/null | grep -q "binary"; then
                continue
            fi
        fi
        
        # Skip lock files and generated files
        if [[ "$file" =~ (package-lock\.json|yarn\.lock|pnpm-lock\.yaml|bun\.lockb)$ ]]; then
            continue
        fi
        
        # Check each pattern
        for pattern in "${patterns[@]}"; do
            if git diff --cached "$file" | grep -qiE "$pattern"; then
                echo -e "${RED}❌ Potential secret found in $file${NC}"
                echo -e "${YELLOW}Pattern matched: $pattern${NC}"
                found_secrets=1
            fi
        done
    done
    
    return $found_secrets
}

# Function to check for hardcoded IPs
check_hardcoded_ips() {
    local files=$(git diff --cached --name-only --diff-filter=ACM | grep -E '\.(ts|tsx|js|jsx)$' || true)
    local found_ips=0
    
    if [ -z "$files" ]; then
        return 0
    fi
    
    for file in $files; do
        # Look for IP addresses (excluding common localhost and example IPs)
        if git diff --cached "$file" | grep -qE '([0-9]{1,3}\.){3}[0-9]{1,3}' && \
           ! git diff --cached "$file" | grep -qE '(127\.0\.0\.1|0\.0\.0\.0|1\.1\.1\.1|8\.8\.8\.8|localhost)'; then
            echo -e "${YELLOW}⚠️  Hardcoded IP address found in $file${NC}"
            echo -e "${YELLOW}Consider using environment variables or configuration${NC}"
            found_ips=1
        fi
    done
    
    return $found_ips
}

# Function to check file sizes
check_file_sizes() {
    local max_size=1048576  # 1MB in bytes
    local large_files=0
    
    for file in $(git diff --cached --name-only --diff-filter=ACM); do
        # Check if file exists (skip deleted files)
        if [ -f "$file" ]; then
            local size=$(wc -c < "$file" 2>/dev/null || echo "0")
            if [ $size -gt $max_size ]; then
                # Format size (use numfmt if available, otherwise show bytes)
                if command -v numfmt >/dev/null 2>&1; then
                    local size_formatted=$(numfmt --to=iec-i --suffix=B $size 2>/dev/null || echo "${size} bytes")
                else
                    local size_formatted="${size} bytes"
                fi
                echo -e "${YELLOW}⚠️  Large file detected: $file ($size_formatted)${NC}"
                echo -e "${YELLOW}Consider using Git LFS for large files${NC}"
                large_files=1
            fi
        fi
    done
    
    return $large_files
}

# Function to check for .env files
check_env_files() {
    local env_files=$(git diff --cached --name-only --diff-filter=ACM | grep -E '\.env$|\.env\.[^.]+$' || true)
    
    if [ -n "$env_files" ]; then
        echo -e "${RED}❌ .env file(s) detected in commit:${NC}"
        echo "$env_files"
        echo -e "${YELLOW}Never commit .env files with sensitive data!${NC}"
        return 1
    fi
    
    return 0
}

# Function to check for debug/console logs in production code
check_debug_statements() {
    local files=$(git diff --cached --name-only --diff-filter=ACM | grep -E '\.(ts|tsx|js|jsx)$' || true)
    local found_debug=0
    
    if [ -z "$files" ]; then
        return 0
    fi
    
    for file in $files; do
        # Skip test files
        if [[ "$file" =~ (\.test\.|\.spec\.|test/|__tests__/) ]]; then
            continue
        fi
        
        # Check for console.log, debugger, etc.
        if git diff --cached "$file" | grep -E '^\+.*console\.(log|debug|trace)' > /dev/null; then
            echo -e "${YELLOW}⚠️  Debug statement found in $file${NC}"
            echo -e "${YELLOW}Consider removing console.log statements before commit${NC}"
            found_debug=1
        fi
    done
    
    # Don't fail on debug statements, just warn
    return 0
}

# Run all checks
exit_code=0

if ! check_secrets; then
    echo -e "${RED}Secret scanning failed!${NC}"
    exit_code=1
fi

if ! check_env_files; then
    echo -e "${RED}.env file check failed!${NC}"
    exit_code=1
fi

# Non-blocking checks (warnings only)
check_hardcoded_ips || true
check_file_sizes || true
check_debug_statements || true

if [ $exit_code -eq 0 ]; then
    echo -e "${GREEN}✅ All security checks passed!${NC}"
else
    echo -e "${RED}❌ Security checks failed. Commit aborted.${NC}"
    echo -e "${YELLOW}If this is a false positive, you can bypass with: git commit --no-verify${NC}"
fi

exit $exit_code
